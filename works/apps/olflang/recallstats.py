'''
This script analyses recall in a modular network (eg: patterns generated by greedy algorithm) by increasing the number of cued HCs during recall
The script was developed for a single network. Need to adapt to 2 networks
'''

import sys, os, select
import csv
import math
import pandas as pd
import numpy as np
import random
import string
import json
from matplotlib import pyplot as plt
from matplotlib import ticker as tck
sys.path.insert(0, '/home/rohan/Documents/BCPNNSimv2/works/misc/')
#from mpl_toolkits.axes_grid1 import make_axes_locatable
import Utils

PATH = '/home/rohan/Documents/BCPNNSimv2/works/apps/olflang/'
buildPATH = '/home/rohan/Documents/BCPNNSimv2/works/build/apps/olflang/' 
figPATH = '/home/rohan/Documents/BCPNNSimv2/works/apps/olflang/Figures/W2V_GreedyAlg/DistortedPats/'
dorun=False
parfilename = "olflangmain1.par"
H = int(Utils.findparamval(PATH+parfilename,"H"))
M = int(Utils.findparamval(PATH+parfilename,"M"))

N = H*M
encoding_thresh = 0.8       # activity threshold to count as active during encoding
recall_thresh = 0.8			# activity threshold to count as active during encoding   IT is set this high because of high background activity level since we have 2 MCs


kelly_colors = ['#BE0032', #Red
				'#F3C300', #Mustard
				'#875692', #Lavender
				'#F38400', #Peach
				'#A1CAF1', #Baby Blue
				'#C2B280', #Grunge greenish brown
				'#848482', #Grey
				'#008856', #Green
				'#E68FAC', #Pink
				'#0067A5', #Blue
				'#F99379', #Light Pink
				'#604E97', #Violet
				'#F6A600', #Orange
				'#B3446C', #Wine Stain red
				'#DCD300', #Slime yellowish green
				'#882D17', #Maroon
				'#8DB600', #Parrot Green
				'#654522', #Brown
				'#E25822', #Dark Pink
				'#2B3D26', #Dark NAvy Blue
				'#F2F3F4', #Off White/Greyish White
				'#222222' #Black
				]

def calc_recallwinner():
	'''
	get a list containing winners at every time step of recall phase based on smallest cosine distance between input patterns and recall activity
	'''

	trpats = Utils.loadbin(buildPATH+"trpats1.bin",N)
	data1 = Utils.loadbin(buildPATH+"act1.log",N).T 	#(units,timestep)

	text_file = open(buildPATH+"simstages.txt", "r")
	#Contains each pattern's encoding start timestep, end of training timestep, start of recall timestep
	simstages = [int(line) for line in text_file]
	text_file.close()
	encoding_steps = simstages[:simstages.index(-1)]
	recall_timelogs = simstages[simstages.index(-1)+1:]
	recall_start_time = recall_timelogs[0]


	recall_score = np.zeros((trpats.shape[0],data1.shape[1]-recall_start_time))
	winner = np.zeros(data1.shape[1]-recall_start_time)
	recall_thresh  = 0.01

	for i,timestep in enumerate(range(recall_start_time, data1.shape[1])):
		act = data1[:,timestep]
		for j,pat in enumerate(trpats):
			recall_score[j,i] = 1 - np.dot(act,pat) / (np.linalg.norm(act)*np.linalg.norm(pat))
		
		#print(np.min(recall_score[:,i]))
		if np.min(recall_score[:,i])<recall_thresh:
			winner[i] = np.argmin(recall_score[:,i]) 
		else:
			winner[i] = None

	#Get duration of activation of each pattern and threshold 
	#winner_pd = pd.Series(winner).value_counts() 

	#return(winner_pd.index.astype(int).tolist())
	return(winner)

def plot_cueHCsvsPats(data,savef=0):

	pat_recall_durations = [[] for i in range(2,H)]
	for i,cueHCs in enumerate(range(2,H)):

		pat_recall_durations[i] = [data[i].tolist().count(x) for x in range(16)]

	pat_recall_durations = np.array(pat_recall_durations)	#(cueHCs,npats)
	
	fig,ax = plt.subplots(1,1,figsize=(15,5))
	for i in range(pat_recall_durations.shape[1]):
		ax.plot(pat_recall_durations[:,i],c=kelly_colors[i],marker='o',markersize=10,linestyle='--')


	print(pat_recall_durations)
	ax.set_ylabel('Duration of Activation (timesteps)')
	ax.set_xticklabels([str(i) for i in range(1,H)])

	ax.set_xlabel('number of cued HCs')
	if savef:
		plt.savefig(figPATH+'Pats_recallduration_vs_cuedHCs',dpi=300)
	#plt.show()

def confusion_mat(winners,cueHCs=0,savef=0):
	cue_order = np.arange(16)

	trpats = Utils.loadbin(buildPATH+"trpats1.bin",N)
	data1 = Utils.loadbin(buildPATH+"act1.log",N).T 	#(units,timestep)

	nstep = int(Utils.findparamval(PATH+parfilename,"recallnstep"))
	ngap = int(Utils.findparamval(PATH+parfilename,"recallngap"))

	text_file = open(buildPATH+"simstages.txt", "r")
	simstages = [int(line) for line in text_file]
	text_file.close()
	encoding_steps = simstages[:simstages.index(-1)]
	recall_timelogs = simstages[simstages.index(-1)+1:]
	recall_start_time = recall_timelogs[0]

	conf_mat = np.zeros([trpats.shape[0],trpats.shape[0]])
	recall_state = np.empty([trpats.shape[0],(nstep+ngap)])
	print(trpats.shape)
	for pat_idx in range(trpats.shape[0]):
		recall_state = winners[cue_order[pat_idx]*(nstep+ngap):(cue_order[pat_idx]+1)*(nstep+ngap)]
		active,counts = np.unique(recall_state,return_counts=True)

		for i,act in enumerate(active):
			if np.isnan(act):
				continue
			else:
				conf_mat[pat_idx,int(act)] = counts[i]/(nstep+ngap)

	fig,ax = plt.subplots(1,1,figsize=(8,8))
	ax.imshow(conf_mat,interpolation='none', aspect='auto',cmap = plt.cm.binary)
	ax.set_xlabel('Recalled',size=14)
	ax.set_ylabel('Cued',size=14)

	#plt.savefig(figPATH+'ConfMat_cueHC{}'.format(cueHCs),dpi=300)
	if savef:
		#plt.savefig(figPATH+'ConfMat_cueHC{}'.format(cueHCs),dpi=300)
		plt.savefig(figPATH+'ConfMat_distortHC8'.format(cueHCs),dpi=300)

	plt.show()

def pat_wdist(savef=0):

	wij11 = Utils.loadbin(buildPATH+"Wij11.bin",N)
	trpats = Utils.loadbin(buildPATH+"trpats1.bin",N)
	within_pats_w = np.zeros([trpats.shape[0],1000])
	print(trpats[1].reshape(15,15))
	between_pats_w = np.zeros([trpats.shape[0],5000])

	for pat_idx1 in range(trpats.shape[0]):
		active_units = np.nonzero(trpats[pat_idx1])[0]
		counter1,counter2 = 0,0
		for act_idx in active_units:
			for pat_idx2 in range(trpats.shape[1]):
				if pat_idx2 in active_units:
					within_pats_w[pat_idx1,counter1] = wij11[act_idx,pat_idx2]
					counter1 += 1
				else:
					between_pats_w[pat_idx1,counter2] = wij11[act_idx,pat_idx2]
					counter2 += 1

	fig,ax = plt.subplots(2,1,figsize=(15,8))
	for i in range(trpats.shape[0]):
		ax[0].hist(within_pats_w[i,:counter1],color=kelly_colors[i],bins=50)
		ax[1].hist(between_pats_w[i,:counter2],color=kelly_colors[i],bins=50)

	print(counter1,counter2)
	ax[0].set_title("Within Patterns")
	ax[1].set_title("Between Patterns")
	if savef:
		plt.savefig(figPATH+'Within_BetweenPats_wdist',dpi=300)
	#plt.show()

def run():
	
	winners = [[] for i in range(2,H)]
	
	for i,cueHCs in enumerate(range(2,H)):
		#Run Sim
		os.chdir('/home/rohan/Documents/BCPNNSimv2/works/build/apps/olflang/')
		os.system("./olflangmain1 "+str(cueHCs))
		winners[i] = calc_recallwinner()

		#Plot Act Plot
		os.chdir(PATH)
		os.system("python3 modular_actplot.py "+str(cueHCs))
		
		confusion_mat(winners[i],cueHCs,savef=1)

	plot_cueHCsvsPats(winners,savef=1)
	pat_wdist(savef=1)
	

def run2():

	winners = calc_recallwinner()
	confusion_mat(winners)

run2()
